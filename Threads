/* Architecture 4 Programmation répartie */

// Objectif du module

    Le fonctionnement d'un ordinateur est basé sur l'execution des processus ou des processus multi-tâches.
    La concurence entre les processus et les tâches au sein d'un système et d'un réseau est à gérer.
    Les raisons sont multiples :

        - la présence des ressources critiques
        - des dépendances entre les processus
        - des séquencements et des ordonnancements à respecter


    Plus généralement, les mêmes problèmes peuvent être présents quand des processus communiquent via le réseau


    PLAN:

    - Rafraichir des connaissance sur les processus et sur les threads

    - Etudies des communication / coopération entre des processus locaux mais aussi distants
        - Communication entre processsus
        - Communication entre tâches (threads)
            --> Réaliser certains services/communications
        - Problèmes issus du fonctionnemen parallèle
            --> Utilisation des ressources critiques et/ou limitées
            --> Synchroniser de processus

    - Etudier les implémentations en JAVA


// Contenu

    - Processus et tâche concurreniels
    - Utilisation concurrentielle des ressources
        - Problème de la concurence
        - Ressources (et sections) critiques
        - Exlusion mutuelle

    - Outils
        - Verrouillage, verrous
        - Sémaphores
        - Barrières

    - Synchronistion des processus

    - Communication entre processus distants
        - Rappels des réseaux
        - Boîtes aux lettres
        - Sockets
        - Modèle client/serveur


// Processus

    Question : Quelles sont les parties d'un programme exécutable ?

    Processus : un programm en cours d'exécution (un programme peut être lancé plusieurs fois)

        - Chaque processus possède :
            - un segment (zone d'adressage contiguë) de texte (du programme) qui est invariant
            - un segment de données qui s'évolue avec l'exécution

        - Contexte du processus : il doit donner les informations usr l'execution des procédures (des fonctions par exemple)
            --> Réalisé sous forme d'une pile d'exécution (pour sauvegarder les contextes, les valeurs passées ...)

        - Contexte du processus : il doit donner les informations sur l'etat du processus
            --> contenu des registres, du compteur ordinal, drapeaux ...

        - Les processus doivent partager (et attendre) les ressources communes (CPU, mémoire, périphériques, fichiers etc ...)


// Communciation entre processus fils et père

    - L'appel systeme fork() crée un processus fils par une copie de son père (zone du texte et de données)

    - Le fils "hérite" des fichiers de redirections, mais utilise des variables, des tampons différents

    - Dans le code :
        - Le fils recoit le code de retour = 0
        - Le père recoit le PID de son fils
        - pas de communication entre les deux pas les varialves (chacun a une copie non partagéee des variables)

    Remarque : dans certains cas, les processus peuvent partager le code mais pas les données


// Communication entre processus (rappel)

    Différentes communication sont possibles entre les porcessus (concurentiels dans un même système)
        - par cade de retour ( exit(n) )
        - par paramètres passée (e.g. argument d'un programme C)
        - par fichiers
        - par tubes nommés (pourquoi pas anonmymes ?)
        - par files de messages
        - pr signaux

    Si les processus qui veulent communiquer tournent sur des machines différentes, ils doivent
        - être connectés (via le réseau)
        - utiliser les services du réseau
        - résoudre des éventuels problemes de communications syncrhonisation et de la concurrence


// Etat d'un processus

    A un moment donné de son existance, un processus est dans un des éts possibles suivnts:

                ----->  Prêt
                |        |
                |        |
                |      election
                |        |
                |        |
             deblocage  Elu
                |        |
                |        |
                |      Blocage
                |        |
                |        |
                |-----  Bloqué

    figure : Etats trasition (simplifiés d'un processus)

    Question : qui décide l'éxecution d'un processus ?


// Processus et JAVA

    Ici, on utilise JAVA qui s’évolue sans cesse
        - Des éléments de la programmation distribué et des conteneurs génériques sont apparus
        - Nous restons à un niveau simple de la programmation JAVA

    Questions :
        - Comment créer un "exécutable" en JAVA (exemple : prog.class) ?
        - Comment exécuter un "exécutable" en JAVA ?
        - Quel est le processus qui s'execute ?
        - Comment faire simplement des programmes distribués ?


// Provessus légers - threads

    Thread : sous-processus qui s’exécutent au sein d’un processus

    - Chaque provessus a une tâche initiale (main)

    - Chaque thread possède :
        - Son propre mot d'etat (PSW), son propre context du processeur
        - Une pile (variables locales)

    - Les threahds partagent :
        - Le code
        - Les données globales et/ou statiques

    - Intérêt : si plusieirs processeurs existent dans le système, des parties penvent être exécutées "independamment"
    - Comme certaines données sont partagées, il faut éviter es conflits et les incohérences

    ...

// Création des threads, héritage de la classe Thread

    - En java la classe qui hérite de la class Thread doit surcharger la méthode run()

    - Une instnce de Affiche_tahce est lancée avec les méthode start() défine patr la classe Thread

            a.start();

    - Après start(), l'objet passe à l'etat "Prêt" (mais ne se démarre pas forcement immédiatement)
      C'est la JVM qui démarre le fonctionnement par l'execution de la méthode run()

    - Le Thread se termine quand la méthode run() se termine


// Thread par implémentation de Runnable

    - On peut aussi créer un Trhead par une calsse qui implémente l'interface Runnable qui neccéssite la méthode run()
        class Affichage_tache2 implements Runnable {
            Affichage_tache2() { ... } // constructeur
            public void run() { ... } // activité
        }
      --> Cette classe n'est ps un thread

    - La classe Thread a une contsrusteur qui prend en compte une instance implkémentant Runnable en argument.
      Su une telle instance de Treah, on appel la méthode start() pour executer la tâche
            public static void main(String[] args) {
                Affichage_tache2 a = new Affichage_tache2();
                Thread t = new Thread(a);
                t.start();
            }
    - le thread se termine quand sa méthode run() se termine


// Méthodes utiles de la classe Thread

    La  classe Thread possède des méthodes pour controler le comportement des threads

        - static void sleep(long ms)
            Le thread sera bloqué pendant ms millesecaonde (d'autres threads êuvent alors s'exécuter)
            Attention : appel avec Treahd.sleep(400)

        - boolean isAlive()
            retourne vair si le thread est  vivant (sa méthode run() n'est pas encore terminée, donc il est "Prêt", "Bloqué" ou "Elu")

        - int getPriority()
          void setPriority()
            Traitent la priorité du thread

        - static void yield()
            le thhread appelant passe le l'etat "Elu" (Runnig) à l'état "Prêt" (Runnable)


// Threads et programme principale

    En C, quand le programmen principale se termine, on quitte l'executable
        - pour attendre la fin de l'exécuion du thread T1 dans le main d'un programme en C :
            int main() {
                pthread_t T1;
                int iret1 = pthread_create( &T1, NULL, th_function,(void*) message1);

                ...

                /* attendre que le thread T1 se termine */
                pthread_join( T1, NULL);
                exit(0);
            }

    Contrairement aux normes POSIX, les threads en Java de sont pas arretés quand le programme pronvipale (letread main) se terminse
            - En Java, le programme ce termine quand les Threads lancés sont terminés
                public class ex2 extends Thread {
                    public void run() {... des impressions : Je suis T1... }

                    public static void main(String args[]) {
                        ex2 T1 = new ex2(1); ex2 T2 = new ex2(2);
                        T1.start(); T2.start();
                        System.out.println("main : T1, T2 sont lancees" );
                        System.out.println("main : termine" );
                    }
                }

                >>> TD1$ java ex2
                main : T1, T2, T3 sont lancees
                main : termine
                Je suis T1 1 ...
                Je suis T2 1 ...

            - Cependant, un Thread peut attendes la fin de l'exécution d'un autre Thread (par ex. t2) en utilisant la méthode join()
                t2.join();


// Partage des variables entre threads

    - Les threads d'un même processus partagent la mémoire
        - Ils penvent accéder aux variables globales
        - ils ont une pile (des variables locales propores) chacun
        - Ils instancient une (dezs) classes(s) ; les règle de l'accessibilité des membres sont les règles connues pour les classes
        - Rappel
            - données proporees de l'objets vs données statiques (partagées)
            - données privées, protégées et publiques


// Exemple du partage

    public class partage extends Thread {

        private static String chaine = "";
        private String nom;
        partage ( String s ) { nom = s; }

        public void run()
        {
            for (int i = 0; i<10; i++)
            {
                chaine = chaine + nom;
                try { Thread.sleep(100); }
                catch(InterruptedException e) {}
            }
        }

        public static void main(String args[]) {
            Thread T1 = new partage( "T1" );
            Thread T2 = new partage( "T2" );
            T1.start();
            T2.start();

            try { sleep(1000); }
            catch(InterruptedException e) {}
            System.out.println( chaineCommune );
        }

    }


// Résultats de l’exécution

    - molnar@molnar-laptop $ java partage
      T1T2T1T2T2T2T2T1T2T1T2T1T2T1T2

    - Au lieu de 2à éléments, il n'y en a que 15

    - Comment expliquer ces résultats ?


// Exécution des programmes concurrentiels

// Un groupe de tâches

// Exemple de Executor

// Résultats de l’exécution

// Un autre Executor

// Résultats de l’exécution

// Problème de l’interface Runnable

    - L'interface a 2 limitations :
        - la methode run() ne peut revoyer aucune valeur (cf. void)
        - On ne peut lance aucune exeption

    - Nouvelle interface dans (java.util.concurent.Callable)
        public interface Callable<V> {
            public V call() throws Exception;
        }

    - Un résultat du type V (programmation template) est prévu


// Exemple de l’interface Callable<V>

// Utilisation des Executors pour des Callable<V>



