/* Architecture 4 Programmation répartie */

// Objectif du module

    Le fonctionnement d'un ordinateur est basé sur l'execution des processus ou des processus multi-tâches.
    La concurence entre les processus et les tâches au sein d'un système et d'un réseau est à gérer.
    Les raisons sont multiples :

        - la présence des ressources critiques
        - des dépendances entre les processus
        - des séquencements et des ordonnancements à respecter


    Plus généralement, les mêmes problèmes peuvent être présents quand des processus communiquent via le réseau


    PLAN:

    - Rafraichir des connaissance sur les processus et sur les threads

    - Etudies des communication / coopération entre des processus locaux mais aussi distants
        - Communication entre processsus
        - Communication entre tâches (threads)
            --> Réaliser certains services/communications
        - Problèmes issus du fonctionnemen parallèle
            --> Utilisation des ressources critiques et/ou limitées
            --> Synchroniser de processus

    - Etudier les implémentations en JAVA


// Contenu

    - Processus et tâche concurreniels
    - Utilisation concurrentielle des ressources
        - Problème de la concurence
        - Ressources (et sections) critiques
        - Exlusion mutuelle

    - Outils
        - Verrouillage, verrous
        - Sémaphores
        - Barrières

    - Synchronistion des processus

    - Communication entre processus distants
        - Rappels des réseaux
        - Boîtes aux lettres
        - Sockets
        - Modèle client/serveur


// Processus

    Question : Quelles sont les parties d'un programme exécutable ?

    Processus : un programm en cours d'exécution (un programme peut être lancé plusieurs fois)

        - Chaque processus possède :
            - un segment (zone d'adressage contiguë) de texte (du programme) qui est invariant
            - un segment de données qui s'évolue avec l'exécution

        - Contexte du processus : il doit donner les informations usr l'execution des procédures (des fonctions par exemple)
            --> Réalisé sous forme d'une pile d'exécution (pour sauvegarder les contextes, les valeurs passées ...)

        - Contexte du processus : il doit donner les informations sur l'etat du processus
            --> contenu des registres, du compteur ordinal, drapeaux ...

        - Les processus doivent partager (et attendre) les ressources communes (CPU, mémoire, périphériques, fichiers etc ...)


// Communciation entre processus fils et père

    - L'appel systeme fork() crée un processus fils par une copie de son père (zone du texte et de données)

    - Le fils "hérite" des fichiers de redirections, mais utilise des variables, des tampons différents

    - Dans le code :
        - Le fils recoit le code de retour = 0
        - Le père recoit le PID de son fils
        - pas de communication entre les deux pas les varialves (chacun a une copie non partagéee des variables)

    Remarque : dans certains cas, les processus peuvent partager le code mais pas les données


// Communication entre processus (rappel)

    Différentes communication sont possibles entre les porcessus (concurentiels dans un même système)
        - par cade de retour ( exit(n) )
        - par paramètres passée (e.g. argument d'un programme C)
        - par fichiers
        - par tubes nommés (pourquoi pas anonmymes ?)
        - par files de messages
        - pr signaux

    Si les processus qui veulent communiquer tournent sur des machines différentes, ils doivent
        - être connectés (via le réseau)
        - utiliser les services du réseau
        - résoudre des éventuels problemes de communications syncrhonisation et de la concurrence


// Etat d'un processus

    A un moment donné de son existance, un processus est dans un des éts possibles suivnts:

                ----->  Prêt
                |        |
                |        |
                |      election
                |        |
                |        |
             deblocage  Elu
                |        |
                |        |
                |      Blocage
                |        |
                |        |
                |-----  Bloqué

    figure : Etats trasition (simplifiés d'un processus)

    Question : qui décide l'éxecution d'un processus ?


// Processus et JAVA

    Ici, on utilise JAVA qui s’évolue sans cesse
        - Des éléments de la programmation distribué et des conteneurs génériques sont apparus
        - Nous restons à un niveau simple de la programmation JAVA

    Questions :
        - Comment créer un "exécutable" en JAVA (exemple : prog.class) ?
        - Comment exécuter un "exécutable" en JAVA ?
        - Quel est le processus qui s'execute ?
        - Comment faire simplement des programmes distribués ?


// Provessus légers - threads

    Thread : sous-processus qui s’exécutent au sein d’un processus

    - Chaque provessus a une tâche initiale (main)

    - Chaque thread possède :
        - Son propre mot d'etat (PSW), son propre context du processeur
        - Une pile (variables locales)

    - Les threahds partagent :
        - Le code
        - Les données globales et/ou statiques

    - Intérêt : si plusieirs processeurs existent dans le système, des parties penvent être exécutées "independamment"
    - Comme certaines données sont partagées, il faut éviter es conflits et les incohérences

    ...


// Création des threads, héritage de la classe Thread

    - En java la classe qui hérite de la class Thread doit surcharger la méthode run()

    - Une instnce de Affiche_tahce est lancée avec les méthode start() défine patr la classe Thread

            a.start();

    - Après start(), l'objet passe à l'etat "Prêt" (mais ne se démarre pas forcement immédiatement)
      C'est la JVM qui démarre le fonctionnement par l'execution de la méthode run()

    - Le Thread se termine quand la méthode run() se termine


// Thread par implémentation de Runnable

    - On peut aussi créer un Trhead par une calsse qui implémente l'interface Runnable qui neccéssite la méthode run()
        class Affichage_tache2 implements Runnable {
            Affichage_tache2() { ... } // constructeur
            public void run() { ... } // activité
        }
      --> Cette classe n'est ps un thread

    - La classe Thread a une contsrusteur qui prend en compte une instance implkémentant Runnable en argument.
      Su une telle instance de Treah, on appel la méthode start() pour executer la tâche
            public static void main(String[] args) {
                Affichage_tache2 a = new Affichage_tache2();
                Thread t = new Thread(a);
                t.start();
            }
    - le thread se termine quand sa méthode run() se termine


// Méthodes utiles de la classe Thread

    La  classe Thread possède des méthodes pour controler le comportement des threads

        - static void sleep(long ms)
            Le thread sera bloqué pendant ms millesecaonde (d'autres threads êuvent alors s'exécuter)
            Attention : appel avec Treahd.sleep(400)

        - boolean isAlive()
            retourne vair si le thread est  vivant (sa méthode run() n'est pas encore terminée, donc il est "Prêt", "Bloqué" ou "Elu")

        - int getPriority()
          void setPriority()
            Traitent la priorité du thread

        - static void yield()
            le thhread appelant passe le l'etat "Elu" (Runnig) à l'état "Prêt" (Runnable)


// Threads et programme principale

    En C, quand le programmen principale se termine, on quitte l'executable
        - pour attendre la fin de l'exécuion du thread T1 dans le main d'un programme en C :
            int main() {
                pthread_t T1;
                int iret1 = pthread_create( &T1, NULL, th_function,(void*) message1);

                ...

                /* attendre que le thread T1 se termine */
                pthread_join( T1, NULL);
                exit(0);
            }

    Contrairement aux normes POSIX, les threads en Java de sont pas arretés quand le programme pronvipale (letread main) se terminse
            - En Java, le programme ce termine quand les Threads lancés sont terminés
                public class ex2 extends Thread {
                    public void run() {... des impressions : Je suis T1... }

                    public static void main(String args[]) {
                        ex2 T1 = new ex2(1); ex2 T2 = new ex2(2);
                        T1.start(); T2.start();
                        System.out.println("main : T1, T2 sont lancees" );
                        System.out.println("main : termine" );
                    }
                }

                >>> TD1$ java ex2
                main : T1, T2, T3 sont lancees
                main : termine
                Je suis T1 1 ...
                Je suis T2 1 ...

            - Cependant, un Thread peut attendes la fin de l'exécution d'un autre Thread (par ex. t2) en utilisant la méthode join()
                t2.join();


// Partage des variables entre threads

    - Les threads d'un même processus partagent la mémoire
        - Ils penvent accéder aux variables globales
        - ils ont une pile (des variables locales propores) chacun
        - Ils instancient une (dezs) classes(s) ; les règle de l'accessibilité des membres sont les règles connues pour les classes
        - Rappel
            - données proporees de l'objets vs données statiques (partagées)
            - données privées, protégées et publiques


// Exemple du partage

    public class partage extends Thread {

        private static String chaine = "";
        private String nom;
        partage ( String s ) { nom = s; }

        public void run()
        {
            for (int i = 0; i<10; i++)
            {
                chaine = chaine + nom;
                try { Thread.sleep(100); }
                catch(InterruptedException e) {}
            }
        }

        public static void main(String args[]) {
            Thread T1 = new partage( "T1" );
            Thread T2 = new partage( "T2" );
            T1.start();
            T2.start();

            try { sleep(1000); }
            catch(InterruptedException e) {}
            System.out.println( chaineCommune );
        }

    }


// Résultats de l’exécution

    - molnar@molnar-laptop $ java partage
      T1T2T1T2T2T2T2T1T2T1T2T1T2T1T2

    - Au lieu de 2à éléments, il n'y en a que 15

    - Comment expliquer ces résultats ?


// Exécution des programmes concurrentiels

    Cas de base :
        - Supposons un seul processeur partagé par plusieurs processus

        - Supposons que le processeur est partagé par plusieurs threads

        - Le contrôle passe d'un thread à l'autre
            - seul le contect des threads (pas exemple la pile) doit être changé

    Ordonnancement :
        - Il existe un ordonnanceur (scheduler) pour gérer les processus/threads

        - Les tâches initialisées, interrompues; bloqué sont mises dans une file

        - Des politiques différentes peuvent être envisagée pour gérer les files d'attentes
            - réaliser un tourniquet (fair play)
            - selection basée sur des priorités ...

    Question : Que fait lacommande nice sous linux ?

    Ordonnaceur :
        - Le thread JAVA à exécuter est choisi parmi les threads qui sont prêts

        - l'ordonnanceur JAVA est :
            -  préemptif (l'ordonnacur peut interrompre une tâche pour donner les ressources à une autre tâche )
            - basé sur une priorité (l'ordonnaceur essaye de donner les ressources à une tâche prioritaire )

        - L'ordonnaceur dépend de l'implémentation de JVM :
             - green thread, c'est la JVM qui implémente l'ordonnacement (UNIX)
             - thread natif, c'es le système d'exploitation hôte de la JVM qui effectue l'ordonnacement

// Un groupe de tâches

Thread Pool
    - Un nombre important de thread peut encombrer la JVM

    - La poilitique, la gestion des threads doit être paramétrée

    - Un groupe de threads, géré par un gestionnaire : thread pool

    - Le système gère les tâches selon sa propore politique et selon l'état des tâches

    - Il est possible de créer des gestionnaire de tâches qui gèrent un ensemble de tâches

    - Les comportement sont définis par les interfaces :

        Executor (pour Runnable)
        ExecutorService (pour Runnable et Callable) implement Executor
        ScheduledExecutorService (pour exécution périodique) implement ExecutorService
            //import java.util.concurrent.Executor;

Interface executor
    - Elle prévoit de "gerer" des threads

    - idée : dissocier la soumission des traitement de leur exécution

    - Une seule méthode :
        void execute (Runnable command)

    - Classes existantes qui l'implémentent
        AbstractExecutorService, ForkJoinPool,
        ScheduledThreadPoolExecutor, ThreadPoolExecutor

    - Implémentation simple :

        class MonExecutor implements Executor {
            public void execute(Runnable r) {
                r.run();
            }
        }

    - Des instances de gestion peuvent être crées par la fabrique Executors
        AbstractExecutorService
        ThreadPoolExecutor
        ScheduledThreadPoolExecutor

    - Différentes créations d'Executor dans la classe Executors

// Exemple de Executor

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

class ex_thread implements Runnable {
    private int nbr;
    // constructeur
    ex_thread (int nb) { nbr=nb; }
    public void run() {
        for (int nombre=1; nombre <10;nombre++) {
            System.out.println("appel de thread " + nbr + " " + nombre);
            try { Thread.sleep(50); // milliseconds
            } catch (InterruptedException e) { }
         }
    }
}

    public class executor_ex {
        public static void main(String args[]) {
            Executor executor = Executors.newSingleThreadExecutor();
                //fabrique d?executor
             ex_thread ex1 = new ex_thread(1);
             ex_thread ex2 = new ex_thread(2);
             executor.execute( ex1);
             executor.execute( ex2);
             }
     }

// Résultats de l'exécution

    - Ce gestionnaire exécute les activités de manière asynchrone vis-à-vis du thread courant,
       mais assure qu?elles seront appelées dans l?ordre de leurs lancements

// Un autre Executor

// Résultats de l’exécution

// Problème de l’interface Runnable

    - L'interface a 2 limitations :
        - la methode run() ne peut revoyer aucune valeur (cf. void)
        - On ne peut lance aucune exception

    - Nouvelle interface dans (java.util.concurent.Callable)

        ublic interface Callable<V> {
            public V call() throws Exception;
        }

    - Un résultat du type V (programmation template) est prévu


// Exemple de l’interface Callable<V>

// Utilisation des Executors pour des Callable<V>





clementcisterne
